(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{446:function(t,v,_){"use strict";_.r(v);var T=_(9),o=Object(T.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"一般理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一般理解"}},[t._v("#")]),t._v(" 一般理解")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("GET通过URL传参，POST通过请求体传参。")])]),t._v(" "),_("p",[t._v("HTTP协议规范里面没有强制性要求GET请求必须把数据都放URL里面，只要服务端支持，可以在请求体写参数，方法使用GET。也可以在URL上写参数，方法使用POST。\nGET请求参数附在URL之后，以?分割URL和传输数据，多个参数用&连接。同样只要服务端支持，GET方法参数写法可以自己约定。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET提交到服务端的数据量小（受限于URL长度），而POST数据量大。")])]),t._v(" "),_("p",[t._v("HTTP协议没有对URL的长度做规定，限制URL长度的大多是浏览器和服务器的配置参数。\n同样的，HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小。\nPHP下可以修改 php.conf 的 postmaxsize 来设置POST的大小")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET参数的数据类型只能是ASCII码，而POST无限制（允许二进制数据）。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET只能进行URL编码，而POST支持多种编码方式。")])]),t._v(" "),_("p",[t._v("GET: application/x-www-form-urlencoded\nPOST: application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET不应用于传递敏感信息，因为参数直接暴露在URL上。")])]),t._v(" "),_("p",[t._v("然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文。\n要想安全传输，就只有加密，也就是HTTPS。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET后退按钮/刷新无害，POST数据会被重新提交")])]),t._v(" "),_("p",[t._v("浏览器应该告知用户数据会被重新提交。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET请求会保存在浏览器的浏览记录中。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET请求的URL能够保存为浏览器书签。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("GET能被缓存，POST不能缓存。")])]),t._v(" "),_("p",[t._v("GET时默认可以复用前面的请求数据作为缓存结果返回，此时以完整的URL作为缓存数据的KEY。\n所以有时候为了强制每次请求都是新数据，我们可以在URL后面加上一个随机参数Math.random或时间戳new Date().getTime()或版本号。")])])]),t._v(" "),_("h2",{attrs:{id:"深入理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深入理解"}},[t._v("#")]),t._v(" 深入理解")]),t._v(" "),_("p",[t._v("RFC7231里定义了HTTP方法的几个性质：")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("Safe - 安全性")])]),t._v(" "),_("blockquote",[_("p",[t._v("安全性的定义：对服务端发起的请求没有引起服务端的任何状态变化，则认为符合安全性。")])]),t._v(" "),_("p",[t._v("注意这里指的不是上面提到的网络安全方面的安全性。\n引入安全性主要是方便爬虫和缓存，以免调用某些不安全的方法引起意外的后果。\n此RFC定义 GET HEAD OPTIONS TRACE 这几个方法是安全的。但这个定义只是规范，并不保证方法的实现也是安全的。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("Idempotent - 幂等性")])]),t._v(" "),_("blockquote",[_("p",[t._v("幂等性的定义：一个请求执行一次和执行多次获得的结果是一致的，则认为符合幂等性。")])]),t._v(" "),_("p",[t._v("引入幂等性主要是为了处理一个请求重复提交的情况，比如请求响应前失去连接，如果请求方法是幂等的，就可以重新发送请求；如果请求方法不幂等，重复请求可能会带来意想不到的后果。\n此RFC定义 PUT DELETE 和安全方法都是幂等的。同样，这只是规范，并不保证服务端实现是否幂等。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("Cacheable - 可缓存性")])]),t._v(" "),_("p",[t._v("就是一个方法是否可以被缓存。\n此RFC定义 GET HEAD 和某些情况下的 POST 都是可缓存的，但大多数浏览器的实现只支持 GET 和 HEAD 。")])])]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("这三个性质一直在强调一个事情：协议不等于实现。\n可以看出，要理解 GET 和 POST 的区别，本质在于"),_("strong",[t._v("语义")]),t._v("的对比而不是"),_("strong",[t._v("语法")]),t._v("的对比：")]),t._v(" "),_("blockquote",[_("p",[t._v("GET的语义是请求获取指定的资源。GET方法的报文主体没有任何语义。\nGET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）。")])]),t._v(" "),_("blockquote",[_("p",[t._v("POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。\nPOST方法是不安全、不幂等、（大部分实现）不可缓存的。")])]),t._v(" "),_("p",[_("strong",[t._v("GET用于获取资源，POST用于处理资源。")])]),t._v(" "),_("h2",{attrs:{id:"post-方法会产生两个-tcp-数据包？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post-方法会产生两个-tcp-数据包？"}},[t._v("#")]),t._v(" POST 方法会产生两个 TCP 数据包？")]),t._v(" "),_("p",[t._v("有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。\nHTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。\n所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。")])])}),[],!1,null,null,null);v.default=o.exports}}]);