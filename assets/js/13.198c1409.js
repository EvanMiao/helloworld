(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{456:function(v,_,t){"use strict";t.r(_);var p=t(9),T=Object(p.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"一般理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一般理解"}},[v._v("#")]),v._v(" 一般理解")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("GET 通过 URL 传参，POST 通过请求体传参。")])]),v._v(" "),t("p",[v._v("HTTP 协议规范里面没有强制性要求 GET 请求必须把数据都放 URL 里面，只要服务端支持，可以在请求体写参数，方法使用 GET。也可以在 URL 上写参数，方法使用 POST。")]),v._v(" "),t("p",[v._v("GET 请求参数附在 URL 之后，以 ? 分割 URL 和传输数据，多个参数用 & 连接。同样只要服务端支持，GET 方法参数写法可以自己约定。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 提交到服务端的数据量小（受限于 URL 长度），而 POST 数据量大。")])]),v._v(" "),t("p",[v._v("HTTP 协议没有对 URL 的长度做规定，限制 URL 长度的大多是浏览器和服务器的配置参数。")]),v._v(" "),t("p",[v._v("同样的，HTTP 协议没有对 POST 进行任何限制，一般是受服务器配置限制或者内存大小。")]),v._v(" "),t("p",[v._v("PHP 下可以修改 php.conf 的 postmaxsize 来设置 POST 的大小")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 参数的数据类型只能是 ASCII 码，而 POST 无限制（允许二进制数据）。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 只能进行 URL 编码，而 POST 支持多种编码方式。")])]),v._v(" "),t("p",[v._v("GET: application/x-www-form-urlencoded")]),v._v(" "),t("p",[v._v("POST: application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 不应用于传递敏感信息，因为参数直接暴露在 URL 上。")])]),v._v(" "),t("p",[v._v("然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文。")]),v._v(" "),t("p",[v._v("要想安全传输，就只有加密，也就是 HTTPS。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 后退按钮/刷新无害，POST 数据会被重新提交")])]),v._v(" "),t("p",[v._v("浏览器应该告知用户数据会被重新提交。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 请求会保存在浏览器的浏览记录中。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 请求的 URL 能够保存为浏览器书签。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GET 能被缓存，POST 不能缓存。")])]),v._v(" "),t("p",[v._v("GET 时默认可以复用前面的请求数据作为缓存结果返回，此时以完整的 URL 作为缓存数据的 KEY。")]),v._v(" "),t("p",[v._v("所以有时候为了强制每次请求都是新数据，我们可以在 URL 后面加上一个随机参数 "),t("code",[v._v("Math.random")]),v._v(" 或时间戳 "),t("code",[v._v("new Date().getTime()")]),v._v(" 或版本号。")])])]),v._v(" "),t("h2",{attrs:{id:"深入理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入理解"}},[v._v("#")]),v._v(" 深入理解")]),v._v(" "),t("p",[v._v("RFC7231 里定义了 HTTP 方法的几个性质：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("Safe - 安全性")])]),v._v(" "),t("blockquote",[t("p",[v._v("安全性的定义：对服务端发起的请求没有引起服务端的任何状态变化，则认为符合安全性。")])]),v._v(" "),t("p",[v._v("注意这里指的不是上面提到的网络安全方面的安全性。")]),v._v(" "),t("p",[v._v("引入安全性主要是方便爬虫和缓存，以免调用某些不安全的方法引起意外的后果。")]),v._v(" "),t("p",[v._v("此 RFC 定义 GET、HEAD、OPTIONS、TRACE 这几个方法是安全的。但这个定义只是规范，并不保证方法的实现也是安全的。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("Idempotent - 幂等性")])]),v._v(" "),t("blockquote",[t("p",[v._v("幂等性的定义：一个请求执行一次和执行多次获得的结果是一致的，则认为符合幂等性。")])]),v._v(" "),t("p",[v._v("引入幂等性主要是为了处理一个请求重复提交的情况，比如请求响应前失去连接，如果请求方法是幂等的，就可以重新发送请求；如果请求方法不幂等，重复请求可能会带来意想不到的后果。")]),v._v(" "),t("p",[v._v("此 RFC 定义 PUT、DELETE 和安全方法都是幂等的。同样，这只是规范，并不保证服务端实现是否幂等。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("Cacheable - 可缓存性")])]),v._v(" "),t("p",[v._v("就是一个方法是否可以被缓存。")]),v._v(" "),t("p",[v._v("此 RFC 定义 GET、HEAD 和某些情况下的 POST 都是可缓存的，但大多数浏览器的实现只支持 GET 和 HEAD 。")])])]),v._v(" "),t("hr"),v._v(" "),t("p",[v._v("这三个性质一直在强调一个事情：协议不等于实现。")]),v._v(" "),t("p",[v._v("可以看出，要理解 GET 和 POST 的区别，"),t("strong",[v._v("本质在于语义的对比而不是语法的对比")]),v._v("：")]),v._v(" "),t("blockquote",[t("p",[v._v("GET 的语义是请求获取指定的资源。GET 方法的报文主体没有任何语义。")])]),v._v(" "),t("p",[v._v("GET 方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader 的约束）。")]),v._v(" "),t("blockquote",[t("p",[v._v("POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。")])]),v._v(" "),t("p",[v._v("POST 方法是不安全、不幂等、（大部分实现）不可缓存的。")]),v._v(" "),t("p",[t("strong",[v._v("GET用于获取资源，POST用于处理资源。")])]),v._v(" "),t("h2",{attrs:{id:"post-方法会产生两个-tcp-数据包吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#post-方法会产生两个-tcp-数据包吗"}},[v._v("#")]),v._v(" POST 方法会产生两个 TCP 数据包吗")]),v._v(" "),t("p",[v._v("有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。")]),v._v(" "),t("p",[v._v("HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试（Chrome）发现，header 和 body 不会分开发送。")]),v._v(" "),t("p",[v._v("所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 POST 必然行为。")])])}),[],!1,null,null,null);_.default=T.exports}}]);