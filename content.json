{"meta":{"title":"Evan Miao","subtitle":null,"description":null,"author":"Evan Miao","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-07-18T04:31:14.000Z","updated":"2019-07-18T04:31:52.224Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"跨域问题及解决方案","slug":"cross-origin","date":"2019-07-16T15:31:05.366Z","updated":"2019-07-18T04:10:56.032Z","comments":true,"path":"2019/07/16/cross-origin/","link":"","permalink":"http://yoursite.com/2019/07/16/cross-origin/","excerpt":"JSONP、CORS 及 postMessage 实现原理","text":"JSONP、CORS 及 postMessage 实现原理 同源策略 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 简单地说，同源策略（Same-origin policy）就是浏览器的一个安全机制，它阻止了脚本与不同源（即跨域）资源的交互。所谓同源，指的是三个相同： 协议相同 域名相同（包括子域名） 端口相同 非同源的限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexDB 无法获取非同源网页的 DOM 元素 无法向非同源地址发送 AJAX 请求 常见跨域场景举例来说： 当前页面url 被请求页面url 是否跨域 原因 www.exmple.com/index.html www.exmple.com/service.php 非跨域 同源 www.exmple.com/index.html www.google.com/service.php 跨域 主域名不同 www.exmple.com/index.html bbs.exmple.com/service/php 跨域 子域名不同 www.exmple.com/index.html www.exmple.com:81/service.php 跨域 端口不同（默认端口为80） www.exmple.com/index.html https://www.exmple.com/service.php 跨域 协议不同 解决方案JSONPJSONP（JSON with Padding）利用 HTML 标签的 src 属性引用资源不受同源策略的影响（支持跨域）的特性达到跨域获取数据的目的。 声明一个回调函数，函数形参为期望获取的服务端返回数据，函数内容为对返回数据的处理。 123var callbackHandler = function (data) &#123; alert(data.name);&#125; 动态生成一个 script 标签，src 为：请求资源的地址 + 获取函数的字段名 + 回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。 1234567// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）var url = \"https://api.exmple.com/service.php?callback=callbackHandler\";// 创建script标签，设置其属性var jsonpScript = document.createElement('script');jsonpScript.setAttribute('src', url);// 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(jsonpScript); 服务端接收到请求后，通过参数获得回调函数名，并将数据放在回调函数的参数中将其返回。 1callbackHandler(&#123;'name':'xxx','age':24&#125;); 浏览器解析 &lt;scrip&gt; 标签时，会自动下载 src 属性值（url）指向的资源，其中的内容会被立即执行。所以浏览器会认为你在调用一个函数，并且传递了一个对象给函数。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 JSON.parse 的步骤。 JSONP 和 AJAX 本质上是不同的东西，AJAX 的核心是通过 XmlHttpRequest 获取非本页内容，而 JSONP 的核心则是动态添加 &lt;script&gt; 标签来调用服务端提供的js脚本。 在jQuery中的用法1234567891011121314$.ajax(&#123; type: \"get\", async: false, url: \"http://api.exmple.com/service.php\", dataType: \"jsonp\", jsonp: \"callback\",// 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback: \"callbackHandler\",// 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 success: function (data) &#123; alert(data.name); &#125;, error: function () &#123; alert('fail'); &#125;&#125;); CORS CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器发现 AJAX 请求跨域时会自动帮我们做一些处理。只要服务端提供支持，前端不需要做额外的事情。所以说实现 CORS 通信的关键是服务端。只要服务端实现了 CORS 接口，就实现了跨域。 简单请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。否则，就属于非简单请求。浏览器对这两种请求的处理不一样。 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单的跨域请求，浏览器会自动在请求的头信息增加一个 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。 123456GET /cors HTTP/1.1Origin: https://api.origin.comHost: api.exmple.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 如果 Origin 指定的源不在许可范围内，服务端会返回一个正常的HTTP回应，但是不会带上 Access-Control-Allow-Origin 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 XMLHttpRequest 的 onerror 回调捕获到。这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200。如果 Origin 指定的源在许可范围内，服务端就会在返回的头信息多出几个字段： 1234Access-Control-Allow-Origin: http://api.origin.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: InfoContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin 必须。它的值是请求时 Origin 字段的值，或者是一个 * ，表示接受任意域名的请求。 Access-Control-Allow-Credentials 可选。它的值是一个布尔值，表示是否允许发送 Cookie 。默认为 true ，也只能设为 true ，如果服务器不要浏览器发送 Cookie ，删除该字段。 Access-Control-Expose-Headers 可选。使 XMLHttpRequest 对象的 getResponseHeader() 方法拿到除6个基本字段之外的其他字段，上面的例子指定， getResponseHeader(&#39;Info&#39;) 可以返回 Info 字段的值。 另外，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果需要发送 Cookie ，除了服务器指定 Access-Control-Allow-Credentials 字段之外，还必须在 AJAX 请求中打开 withCredentials 属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 需要注意的是，如果要发送 Cookie ， Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时， Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie 。 非简单请求非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 预检请求的发送请求： 12345678OPTIONS /cors HTTP/1.1Origin: https://api.origin.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.example.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是 OPTIONS ，表示这个请求是用来询问的。头信息里面，关键字段是 Origin ，表示请求来自哪个源。除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method 必须。用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header 。 预检请求的返回： 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: https://api.origin.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain Access-Control-Allow-Methods 必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Max-Age 可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 postMessage postMessage 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API ，用于实现不同窗口不同页面的跨域通信。 发送数据语法： 1otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames 。 message 将要发送到其他窗口的数据。 targetOrigin 目标窗口的源（协议 + 域名 + 端口）。也可以设为 * ，表示不限制域名，向所有窗口发送。如果要指定和当前窗口同源的话设置为 / 。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的 targetOrigin ，而不是 * 。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选。是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接收数据父窗口和子窗口都可以通过 message 事件，监听对方的消息。 123window.addEventListener('message', function(event) &#123; console.log(event.data);&#125;, false); message 事件监听函数接收一个参数，event 对象实例，该对象有三个属性： event.data ：消息内容 event.origin ：消息发向的网址 event.origin 属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; if (event.origin !== 'http://api.origin.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; event.source ：发送消息的窗口 下面的例子是，子窗口通过 event.source 属性引用父窗口，然后发送消息。 1234window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; event.source.postMessage('Nice to see you!', '*');&#125; 其他方案代理服务器 nginx 反向代理 document.domain window.name window.location.hash websocket CSST (CSS Text Transformation) flash","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"GET 和 POST 的区别","slug":"get-post","date":"2019-07-05T06:26:41.400Z","updated":"2019-07-18T04:30:17.113Z","comments":true,"path":"2019/07/05/get-post/","link":"","permalink":"http://yoursite.com/2019/07/05/get-post/","excerpt":"要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比： GET用于获取资源，安全，幂等，可缓存。 POST用于处理资源，不安全，不幂等，不可缓存。","text":"要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比： GET用于获取资源，安全，幂等，可缓存。 POST用于处理资源，不安全，不幂等，不可缓存。 一般理解 GET通过URL传参，POST通过请求体传参。HTTP协议规范里面没有强制性要求GET请求必须把数据都放URL里面，只要服务端支持，可以在请求体写参数，方法使用GET。也可以在URL上写参数，方法使用POST。GET请求参数附在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。同样只要服务端支持，GET方法参数写法可以自己约定。 GET提交到服务端的数据量小（受限于URL长度），而POST数据量大。HTTP协议没有对URL的长度做规定，限制URL长度的大多是浏览器和服务器的配置参数。同样的，HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小。PHP下可以修改 php.conf 的 postmaxsize 来设置POST的大小 GET参数的数据类型只能是ASCII码，而POST无限制（允许二进制数据）。 GET只能进行URL编码，而POST支持多种编码方式。GET: application/x-www-form-urlencodedPOST: application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 GET不应用于传递敏感信息，因为参数直接暴露在URL上。然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是HTTPS。 GET后退按钮/刷新无害，POST数据会被重新提交浏览器应该告知用户数据会被重新提交。 GET请求会保存在浏览器的浏览记录中。 GET请求的URL能够保存为浏览器书签。 GET能被缓存，POST不能缓存。GET时默认可以复用前面的请求数据作为缓存结果返回，此时以完整的URL作为缓存数据的KEY。所以有时候为了强制每次请求都是新数据，我们可以在URL后面加上一个随机参数Math.random或时间戳new Date().getTime()或版本号。 深入理解RFC7231里定义了HTTP方法的几个性质： Safe - 安全性 安全性的定义：对服务端发起的请求没有引起服务端的任何状态变化，则认为符合安全性。 注意这里指的不是上面提到的网络安全方面的安全性。引入安全性主要是方便爬虫和缓存，以免调用某些不安全的方法引起意外的后果。此RFC定义 GET HEAD OPTIONS TRACE 这几个方法是安全的。但这个定义只是规范，并不保证方法的实现也是安全的。 Idempotent - 幂等性 幂等性的定义：一个请求执行一次和执行多次获得的结果是一致的，则认为符合幂等性。 引入幂等性主要是为了处理一个请求重复提交的情况，比如请求响应前失去连接，如果请求方法是幂等的，就可以重新发送请求；如果请求方法不幂等，重复请求可能会带来意想不到的后果。此RFC定义 PUT DELETE 和安全方法都是幂等的。同样，这只是规范，并不保证服务端实现是否幂等。 Cacheable - 可缓存性 就是一个方法是否可以被缓存。此RFC定义 GET HEAD 和某些情况下的 POST 都是可缓存的，但大多数浏览器的实现只支持 GET 和 HEAD 。 这三个性质一直在强调一个事情：协议不等于实现。可以看出，要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比： GET的语义是请求获取指定的资源。GET方法的报文主体没有任何语义。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）。 POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST方法是不安全、不幂等、（大部分实现）不可缓存的。 GET用于获取资源，POST用于处理资源。 POST 方法会产生两个 TCP 数据包？有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"AJAX请求的四个步骤","slug":"ajax","date":"2019-07-01T09:38:30.301Z","updated":"2019-07-18T04:30:23.876Z","comments":true,"path":"2019/07/01/ajax/","link":"","permalink":"http://yoursite.com/2019/07/01/ajax/","excerpt":"AJAX的全称：异步的JavaScript和XML(Asynchronous JavaScript and XML) AJAX不是某种编程语言 是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术","text":"AJAX的全称：异步的JavaScript和XML(Asynchronous JavaScript and XML) AJAX不是某种编程语言 是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术 1.创建XMLHttpRequest对象1var xhr = new XMLHttpRequest(); IE5或IE6兼容处理 123456var xhr;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 2.配置请求信息1open(method,url,async) method：请求方式 —— GET / POSTurl：请求的地址async：true（异步）或 false（同步） 使用GET请求参数加在url后面 1xhr.open(\"GET\", \"server.php?num=100\"); 使用POST请求需要配置请求头信息 12xhr.open(\"POST\", \"server.php\");xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); 3.发送请求 send 方法发送请求，并接受一个可选参数 1send(string) 使用GET请求可以不传或传入 null 1xhr.send(); 使用POST请求可以将请求体的参数传入 1xhr.send(\"num=100\"); 4.创建响应函数12345xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125;&#125;; responseText：获得字符串形式的相应数据。responsXML：获得XML形式的相应数据。status和statusText：以数字和文本形式返回http状态码。getAllResponseHeader()：获取所有的响应报头。getResponseHeader()：查询响应中的某个字段的值。 readyState属性： 响应返回成功的时候得到通知。0：请求未初始化，open还没有调用。1：服务器连接已建立，open已经调用了。2：请求已经接收，也就是接收到头信息了。3：请求处理中，也就是接收到响应主体了。4：请求已完成，且响应已就绪，也就是响应完成了。 http状态码： HTTP状态码由3位数字构成，其中首位数字定义了状态码的类型：1XX：信息类，表示收到Web浏览器请求，正在进一步的处理中2XX：成功，表示用户请求被正确接收，理解和处理。例如：200 OK3XX：重定向，表示请求没有成功，客户必须采取进一步的动作4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found，意味着请求中所引用的文档不存在。5XX：服务器错误，表示服务器不能完成对请求的处理。例如：500","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-21T10:49:39.694Z","updated":"2019-07-01T13:38:11.897Z","comments":true,"path":"2019/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}