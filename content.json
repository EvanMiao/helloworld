{"meta":{"title":"Evan Miao","subtitle":null,"description":"很惭愧，就做了一点微小的工作。","author":"Evan Miao","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-07-18T04:31:14.000Z","updated":"2019-07-18T04:31:52.224Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 函数防抖与函数节流","slug":"debounce-throttle","date":"2019-07-31T16:05:50.383Z","updated":"2019-08-01T09:38:26.797Z","comments":true,"path":"2019/08/01/debounce-throttle/","link":"","permalink":"http://yoursite.com/2019/08/01/debounce-throttle/","excerpt":"函数防抖(debounce)与函数节流(throttle)两者都是优化高频率执行 JS 代码的一种手段","text":"函数防抖(debounce)与函数节流(throttle)两者都是优化高频率执行 JS 代码的一种手段 概念解释一些短时间内频繁触发的事件，如果在事件触发时执行代码块，会将代码块重复执行很多次。很可能造成浏览器卡顿，甚至崩溃。可通过函数防抖和函数节流来避免这种情况。 函数防抖(debounce)事件被触发指定时间后执行回调函数，如果事件在这指定时间内又被触发，则重新计时。 实现思路：每次触发事件时都取消之前的延时调用方法： 1234567891011121314/** * @param fn &#123;function&#125; 回调函数（要防抖的函数） * @param delay &#123;number&#125; 规定的时间 */function debounce(fn, delay) &#123; var timer = null; return function (args) &#123; // 取消之前的延时调用 clearTimeout(timer); timer = setTimeout(function () &#123; fn.apply(this, args); &#125;, delay); &#125;&#125; 函数节流(throttle)事件在指定时间内被触发多次只会执行一次回调函数。 定时器方案实现思路：每次触发事件时都判断当前是否有等待执行的延时函数： 1234567891011121314function throttle(fn, delay) &#123; var flag = false; return function (args) &#123; // 判断之前的调用是否完成 if (flag) &#123; return false; &#125; flag = true; setTimeout(function () &#123; fn.apply(this, args); flag = false; &#125;, delay) &#125;&#125; 时间戳方案实现思路：每次触发事件时都比对当前时间与上一次执行时间的时间差与规定时间的大小关系： 12345678910111213function throttle(fn, delay) &#123; // 记录上一次函数触发的时间 var lastTime = 0; return function (args) &#123; // 记录当前函数触发的时间 var nowTime = Date.now(); if (nowTime - lastTime &gt; delay) &#123; fn.apply(this, args); // 同步时间 lastTime = nowTime; &#125; &#125;&#125; 应用场景 debounce search搜索联想；手机号、邮箱验证输入检测。用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候。只需窗口调整完成后，计算窗口大小。防止重复渲染。 throttle canvas 模拟画板，mousemove DOM 元素推拽（不使用 H5 Drag&amp;Drop API），mousemove 射击游戏，mousedown / keydown (单位时间内只能发射一颗子弹) 监听滚动事件是否滑到底部自动加载更多","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"JavaScript 中的 this 指向问题","slug":"this","date":"2019-07-20T00:56:22.008Z","updated":"2019-07-20T09:35:37.611Z","comments":true,"path":"2019/07/20/this/","link":"","permalink":"http://yoursite.com/2019/07/20/this/","excerpt":"一般情况下， this 不是函数定义时被绑定，而是函数调用时被绑定。箭头函数中的 this 在函数定义的时被绑定，指向的是它的外层调用者绑定的 this 。this 绑定的四种方式：默认绑定、隐式绑定、显式绑定、构造绑定。","text":"一般情况下， this 不是函数定义时被绑定，而是函数调用时被绑定。箭头函数中的 this 在函数定义的时被绑定，指向的是它的外层调用者绑定的 this 。this 绑定的四种方式：默认绑定、隐式绑定、显式绑定、构造绑定。 默认绑定直接调用一个函数，并在这个函数中使用 this ，非严格模式下这个 this 默认指向全局对象（浏览器是window，Node中是global），严格模式下这个 this 是 undefined 。 1234567var a = 0;function test () &#123; console.log(this.a);&#125;test(); // 0 隐式绑定作为对象方法调用时，函数中的 this 指向上级对象。 123456789101112var a = 0;function test () &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;obj.test(); // 1 函数 test 作为 obj 对象的方法被调用，this 指向 obj 对象。一句话，被谁调用就指向谁。 1234567891011121314151617var a = 0;function test () &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;var obj2 = &#123; a: 2, obj&#125;obj2.obj.test(); // 1 指向直属上级对象（直接调用者）。 1234567891011121314var a = 0;function test () &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;var test2 = obj.test;test2(); // 0 test2 是直接调用，默认绑定全局对象。只看函数调用时的调用者。 12345678910111213var a = 0;function test () &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;setTimeout(obj.test); // 0setTimeout('obj.test()'); // 1 setTimeout(obj.test) 的参数接收了一个函数（ obj 对象的 test ）， setTimeout 代码执行时直接调用传入的函数，函数的调用者是全局对象；setTimeout(&#39;obj.test()&#39;) 的参数接受了一段可执行代码， setTimeout 执行时通过 obj 对象来找到 test 函数并调用执行，函数的调用者是 obj 对象。 显式绑定call()、apply()call() 和 apply() 是函数的方法，作用是改变函数的调用对象。它的第一个参数指定改变后的调用这个函数的对象。call() 方法的作用和 apply() 方法类似，区别就是 call() 方法第二个参数接受的是参数列表，而 apply() 方法接受的是一个参数数组。 123456789101112131415var a = 0;function test() &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;test2 = obj.test;test2.call(obj); // 1test2.apply(obj); // 1 this 指向 call() 或 apply() 的第一个参数。 123456789101112var a = 0;function test() &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;obj.test.apply(); // 0 非严格模式下，参数为空或 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象）；值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 bind() bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 bind() 方法与 call() 方法和 apply() 方法类似，区别是 bind 会创建一个新的函数，我们必须要手动去调用。而 call 和 apply 会立即调用执行。 1234567891011121314var a = 0;function test() &#123; console.log(this.a);&#125;var obj = &#123; a: 1, test&#125;;test2 = obj.test;test.bind(obj)(); // 1 需要注意的是，使用call 和 apply 时，如果函数用 bind 绑定了 this 对象，那么 call 和 apply 不会像预期那样执行，比如： 12345678910111213141516var a = 0;function test() &#123; console.log(this.a);&#125;var obj = &#123; a: 1&#125;;var test2 = test.bind(&#123;&#125;);// 期望 this 指向 obj ，即输出 1// 但是因为 test2 绑定了不是 obj 的对象，所以会输出 undefinedtest.apply(obj); // 1test2.apply(obj); // undefined 构造绑定用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。 123456789101112var a = 0;function test(a) &#123; this.a = a;&#125;var b = new test(1);console.log(b.a); // 1console.log(a); // 0var c = new test(1);console.log(b === c); // false 箭头函数箭头函数中的 this 在函数定义的时被绑定，指向的是它的外层调用者绑定的 this 。 123456789101112var a = 0;var test = () =&gt; &#123; console.log(this.a)&#125;;var obj = &#123; a: 1, test&#125;;obj.test(); // 0 箭头函数不能用 new 调用，不能 bind 到某个对象（虽然 bind() 方法调用没问题，但是不会产生预期效果）。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数（即包含它的最近的一层函数或函数表达式）绑定的 this 。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"跨域问题及解决方案","slug":"cross-origin","date":"2019-07-16T15:31:05.366Z","updated":"2019-07-16T15:58:52.950Z","comments":true,"path":"2019/07/16/cross-origin/","link":"","permalink":"http://yoursite.com/2019/07/16/cross-origin/","excerpt":"JSONP、CORS 及 postMessage 实现原理","text":"JSONP、CORS 及 postMessage 实现原理 同源策略 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 简单地说，同源策略（Same-origin policy）就是浏览器的一个安全机制，它阻止了脚本与不同源（即跨域）资源的交互。所谓同源，指的是三个相同： 协议相同 域名相同（包括子域名） 端口相同 非同源的限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexDB 无法获取非同源网页的 DOM 元素 无法向非同源地址发送 AJAX 请求 常见跨域场景举例来说： 当前页面url 被请求页面url 是否跨域 原因 www.exmple.com/index.html www.exmple.com/service.php 非跨域 同源 www.exmple.com/index.html www.google.com/service.php 跨域 主域名不同 www.exmple.com/index.html bbs.exmple.com/service/php 跨域 子域名不同 www.exmple.com/index.html www.exmple.com:81/service.php 跨域 端口不同（默认端口为80） www.exmple.com/index.html https://www.exmple.com/service.php 跨域 协议不同 解决方案JSONPJSONP（JSON with Padding）利用 HTML 标签的 src 属性引用资源不受同源策略的影响（支持跨域）的特性达到跨域获取数据的目的。 声明一个回调函数，函数形参为期望获取的服务端返回数据，函数内容为对返回数据的处理。 123var callbackHandler = function (data) &#123; alert(data.name);&#125; 动态生成一个 script 标签，src 为：请求资源的地址 + 获取函数的字段名 + 回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。 1234567// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）var url = \"https://api.exmple.com/service.php?callback=callbackHandler\";// 创建script标签，设置其属性var jsonpScript = document.createElement('script');jsonpScript.setAttribute('src', url);// 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(jsonpScript); 服务端接收到请求后，通过参数获得回调函数名，并将数据放在回调函数的参数中将其返回。 1callbackHandler(&#123;'name':'xxx','age':24&#125;); 浏览器解析 &lt;scrip&gt; 标签时，会自动下载 src 属性值（url）指向的资源，其中的内容会被立即执行。所以浏览器会认为你在调用一个函数，并且传递了一个对象给函数。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 JSON.parse 的步骤。 JSONP 和 AJAX 本质上是不同的东西，AJAX 的核心是通过 XmlHttpRequest 获取非本页内容，而 JSONP 的核心则是动态添加 &lt;script&gt; 标签来调用服务端提供的js脚本。 在jQuery中的用法1234567891011121314$.ajax(&#123; type: \"get\", async: false, url: \"http://api.exmple.com/service.php\", dataType: \"jsonp\", jsonp: \"callback\",// 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback: \"callbackHandler\",// 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 success: function (data) &#123; alert(data.name); &#125;, error: function () &#123; alert('fail'); &#125;&#125;); CORS CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器发现 AJAX 请求跨域时会自动帮我们做一些处理。只要服务端提供支持，前端不需要做额外的事情。所以说实现 CORS 通信的关键是服务端。只要服务端实现了 CORS 接口，就实现了跨域。 简单请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。否则，就属于非简单请求。浏览器对这两种请求的处理不一样。 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单的跨域请求，浏览器会自动在请求的头信息增加一个 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。 123456GET /cors HTTP/1.1Origin: https://api.origin.comHost: api.exmple.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 如果 Origin 指定的源不在许可范围内，服务端会返回一个正常的HTTP回应，但是不会带上 Access-Control-Allow-Origin 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 XMLHttpRequest 的 onerror 回调捕获到。这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200。如果 Origin 指定的源在许可范围内，服务端就会在返回的头信息多出几个字段： 1234Access-Control-Allow-Origin: http://api.origin.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: InfoContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin 必须。它的值是请求时 Origin 字段的值，或者是一个 * ，表示接受任意域名的请求。 Access-Control-Allow-Credentials 可选。它的值是一个布尔值，表示是否允许发送 Cookie 。默认为 true ，也只能设为 true ，如果服务器不要浏览器发送 Cookie ，删除该字段。 Access-Control-Expose-Headers 可选。使 XMLHttpRequest 对象的 getResponseHeader() 方法拿到除6个基本字段之外的其他字段，上面的例子指定， getResponseHeader(&#39;Info&#39;) 可以返回 Info 字段的值。 另外，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果需要发送 Cookie ，除了服务器指定 Access-Control-Allow-Credentials 字段之外，还必须在 AJAX 请求中打开 withCredentials 属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 需要注意的是，如果要发送 Cookie ， Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时， Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie 。 非简单请求非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 预检请求的发送请求： 12345678OPTIONS /cors HTTP/1.1Origin: https://api.origin.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.example.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是 OPTIONS ，表示这个请求是用来询问的。头信息里面，关键字段是 Origin ，表示请求来自哪个源。除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method 必须。用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header 。 预检请求的返回： 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: https://api.origin.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain Access-Control-Allow-Methods 必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Max-Age 可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 postMessage postMessage 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API ，用于实现不同窗口不同页面的跨域通信。 发送数据语法： 1otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames 。 message 将要发送到其他窗口的数据。 targetOrigin 目标窗口的源（协议 + 域名 + 端口）。也可以设为 * ，表示不限制域名，向所有窗口发送。如果要指定和当前窗口同源的话设置为 / 。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的 targetOrigin ，而不是 * 。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选。是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接收数据父窗口和子窗口都可以通过 message 事件，监听对方的消息。 123window.addEventListener('message', function(event) &#123; console.log(event.data);&#125;, false); message 事件监听函数接收一个参数，event 对象实例，该对象有三个属性： event.data ：消息内容 event.origin ：消息发向的网址 event.origin 属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; if (event.origin !== 'http://api.origin.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; event.source ：发送消息的窗口 下面的例子是，子窗口通过 event.source 属性引用父窗口，然后发送消息。 1234window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; event.source.postMessage('Nice to see you!', '*');&#125; 其他方案代理服务器 nginx 反向代理 document.domain window.name window.location.hash websocket CSST (CSS Text Transformation) flash","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"JavaScript 作用域与作用域链","slug":"scope","date":"2019-07-14T14:55:10.707Z","updated":"2019-07-25T11:20:24.841Z","comments":true,"path":"2019/07/14/scope/","link":"","permalink":"http://yoursite.com/2019/07/14/scope/","excerpt":"当查找变量的时候，会先从当前执行上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。","text":"当查找变量的时候，会先从当前执行上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 作用域作用域就是变量与函数的可访问范围。作用域的最大用途就是隔离变量或函数，并控制变量或函数的生命周期。 全局作用域在整个程序生命周期内都是有效的，在任意的函数内部都能访问的变量或函数拥有全局作用域。 以下几种情况拥有全局作用域： 定义在最外层的函数和变量： 12345678910111213141516var a = 0;function test() &#123; var b = 1; function test2() &#123; console.log(b); &#125; test2();&#125;console.log(a); // 0console.log(b); // ReferenceError: b is not definedtest(); // 1test2(); // ReferenceError: test2 is not defined 未经声明就赋值的变量： 1234567function test() &#123; var a = 0; b = 1;&#125;console.log(a); // ReferenceError: a is not definedconsole.log(b); // 1 window 的属性： 一般情况下， window 对象的内置属性都拥有全局作用域，例如 window.name 、 window.location 、 window.top 等等。 这里需要注意的是 var 声明的全局变量以及未经声明就赋值的变量会挂载到 window 属性上，但是 var 声明的变量不能删除，未经声明的变量可以删除。 函数作用域在某个函数内部声明的变量或函数拥有函数作用域。它们只能被该函数的语句使用，函数外部是不可访问的。函数在创建的时候，变量和函数的函数作用域已经确定下来。函数的参数也属于函数内部的变量，因此拥有函数作用域。 123456789101112function test() &#123; var a = 1; function test2() &#123; console.log(a); &#125; test2();&#125;console.log(a); // ReferenceError: a is not definedtest2(); // ReferenceError: test2 is not defined 函数定义语句中函数会被提升到作用域顶部，而函数表达式则不会。 12345678910111213a(); // I am ab(); // TypeError: b is not a functionconsole.log(typeof b); // undefinedfunction a() &#123; console.log('I am a');&#125;var b = function () &#123; console.log('I am b');&#125;b(); // I am b 函数不能相互调用各自的作用域，虽然它们可以互相调用。 12345678910function test() &#123; var a = 0;&#125;function test2() &#123; test(); console.log(a);&#125;test2(); // ReferenceError: a is not defined 当一个函数在另一个函数内定义，内部的函数能够访问外部函数的变量。我们称之为词法作用域。 然而，外部的函数不能够访问内部函数的变量。 12345678910111213function test() &#123; var a = 0; function test2() &#123; var b = 1; console.log(a); &#125; test2(); // 0 console.log(b);&#125;test(); // ReferenceError: b is not defined 块级作用域在ES6之前是没有块级作用域的，ES6引入了 let 、 const 关键字就可以创建块级作用域。 12345for(var i = 0; i &lt; 5; i++) &#123; // ...&#125;console.log(i); // 5 用 var 关键字声明的变量，在 for 循环结束之后仍然被保留在当前作用域里，可以使用 let 关键字代替 var 关键字： 12345for(let i = 0; i &lt; 5; i++) &#123; // ...&#125;console.log(i); // ReferenceError: i is not defined 同样能形成块级作用域的还有 const 关键字： 12345if (true) &#123; const a = 0;&#125;console.log(a); // ReferenceError: a is not defined 执行上下文函数调用都有与之相关的作用域和上下文。从根本上说，作用域（scope）是基于函数（function-based）而上下文（context）是基于对象（object-based）。 作用域：变量的可见性 上下文： 在相同作用域下的 this 值 一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，多次调用一个函数会导致创建多个执行上下文。一个函数可以产生无数个执行上下文，一系列的执行上下文从逻辑上形成了执行上下文栈，栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当函数执行完毕，它所产生的执行上下文被销毁。 JavaScript 属于解释型语言，JavaScript 的执行分为解释和执行两个阶段，这两个阶段所做的事并不一样： 解释阶段： 词法分析 语法分析 作用域规则确定 执行阶段： 创建执行上下文 执行函数代码 垃圾回收 JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。 作用域和执行上下文之间最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。 执行上下文三属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 变量对象 VO变量对象（variable object）是与执行上下文相关的数据作用域（scope of data）。它是与上下文关联的特殊对象，用于存储被定义在上下文中的变量（variables）和函数声明（function declarations）。它是一个抽象的概念，不同的上下文中，它表示使用不同的 object 。例如，在 global 全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。 进入执行上下文时， VO 的初始化过程具体如下： 函数的形参（当进入函数执行上下文时） 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为 undefined 。 函数声明（FunctionDeclaration, FD） 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值。 变量声明（var，VariableDeclaration） 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。 执行代码的时候，VO的一些Undefined值会被确定。 活动对象 AO当函数被调用者激活，这个特殊的活动对象（activation object）就被创建了。它包含普通参数（formal parameters）与特殊参数（arguments）对象（具有索引属性的参数映射表）。活动对象在函数上下文中作为变量对象使用。 即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象 arguments 。 AO 是在进入函数的执行上下文时创建的，并为该对象初始化一个 arguments 属性，该属性的值为 Arguments 对象。 作用域链当查找变量的时候，会先从当前执行上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链（scope chain）。 过程如下： 任何在执行上下文时刻的作用域都由作用域链来实现。 在一个函数被定义的时候，会将它定义时刻的 scope chain 链接到这个函数对象的 [[scope]] 属性。 在一个函数对象被调用的时候，会创建一个活动对象（也就是一个对象），然后对于每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象做为此时的作用域链(scope chain)最前端，并将这个函数对象的 [[scope]] 加入到 scope chain 中。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"JavaScript 原型与原型链","slug":"prototype","date":"2019-07-10T09:31:30.527Z","updated":"2019-07-10T11:00:01.004Z","comments":true,"path":"2019/07/10/prototype/","link":"","permalink":"http://yoursite.com/2019/07/10/prototype/","excerpt":"每个实例对象（object）都有一个私有属性（__proto__）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null 。根据定义， null 没有原型，并作为这个原型链中的最后一个环节。","text":"每个实例对象（object）都有一个私有属性（__proto__）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null 。根据定义， null 没有原型，并作为这个原型链中的最后一个环节。 prototypeprototype 属性是函数所独有的，指向函数的原型对象。当使用这个构造函数创建实例的时候，prototype 属性指向的原型对象就成为实例的原型对象。prototype 属性定义了构造函数构造出来的共有祖先，构造函数产生的实例对象可以继承该属性的方法和属性。 12345678function Test() &#123;&#125;Test.prototype.a = 0;var t1 = new Test();var t2 = new Test();console.log(t1.a); // 0console.log(t2.a); // 0 __proto__所有对象都拥有一个内部属性 [[prototype]] ，指向它的原型对象，这个属性可以通过 Object.getPrototypeOf(obj) 或 obj.__proto__ 来访问。 __prototype__ 属性指向的对象与创建它的构造函数的 prototype 属性所指向的对象是同一个，即实例对象的 __proto__ 指向其构造函数的 prototype 。 123function Test() &#123;&#125;var t = new Test();console.log(t.__proto__ === Test.prototype); // true 凡是通过 new Function() 创建的对象都是函数对象（包含 Function 自身），所有函数对象的 __proto__ 属性都指向 Function.prototype ，它是一个空函数（Empty function）。 12function Test() &#123;&#125;console.log(Test.__proto__ === Function.prototype); // true Function.__proto__ 和 Function.prototype 为同一对象。 Object Array String 等构造函数本质上和 Function 一样，均继承于 Function.prototype 。因此也就指向 Function.prototype 。 123456789101112131415console.log(Function.__proto__ === Function.prototype); // trueconsole.log(Object.__proto__ === Function.prototype); // trueconsole.log(Array.__proto__ === Function.prototype); // trueconsole.log(String.__proto__ === Function.prototype); // trueconsole.log(Boolean.__proto__ === Function.prototype); // trueconsole.log(RegExp.__proto__ === Function.prototype); // trueconsole.log(Error.__proto__ === Function.prototype); // trueconsole.log(Date.__proto__ === Function.prototype); // true Math ， JSON 是以对象形式存在的，无需 new 。它们的 __proto__ 属性指向 Object.prototype 。 123console.log(Math.__proto__ === Object.prototype); // trueconsole.log(JSON.__proto__ === Object.prototype); // true 原型对象也是对象，是通过 Object 构造函数生成的，它的 __proto__ 属性指向 Object.prototype 。 Object.prototype 是原型链的尽头（ root ）。所有对象均从 Object.prototype 继承属性。 12function Test() &#123;&#125;console.log(Test.prototype.__proto__ === Object.prototype); // true 同理， Function.prototype 直接继承 root （ Object.prototype ） 1console.log(Function.prototype.__proto__ === Object.prototype); // true Object.prototype 的 __proto__ 属性指向 null 。 1console.log(Object.prototype.__proto__ === null); // true constructor原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。 12345function Test() &#123;&#125;console.log(Test === Test.prototype.constructor); // truevar t = new Test();console.log(t.constructor === Test); // true 注意， t 对象本身不具有 constructor 属性，所以会通过 __proto__ 属性到原型链中找，而 t.__proto__ === Test.prototype ， Test.prototype 具有 constructor 属性并指向 Test 函数，故 t.constructor 指向了 Test ，它不是 t 自己本身拥有的，是继承而来的。 原型链在 JavaScript 中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。 有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。 当访问一个对象的属性时，如果该对象内部找不到，就会去它的 __proto__ 属性所指向的那个对象（原型对象）里找，如果还是找不到就会访问原型对象的 __proto__ 属性（原型的原型），依次层层向上搜索，直到 null 。此时若还没找到，浏览器断言该属性不存在，并给出属性值为 undefined 的结论。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"GET 和 POST 的区别","slug":"get-post","date":"2019-07-05T06:26:41.400Z","updated":"2019-07-05T11:00:59.885Z","comments":true,"path":"2019/07/05/get-post/","link":"","permalink":"http://yoursite.com/2019/07/05/get-post/","excerpt":"要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比：GET用于获取资源，安全，幂等，可缓存。POST用于处理资源，不安全，不幂等，不可缓存。","text":"要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比：GET用于获取资源，安全，幂等，可缓存。POST用于处理资源，不安全，不幂等，不可缓存。 一般理解 GET通过URL传参，POST通过请求体传参。HTTP协议规范里面没有强制性要求GET请求必须把数据都放URL里面，只要服务端支持，可以在请求体写参数，方法使用GET。也可以在URL上写参数，方法使用POST。GET请求参数附在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。同样只要服务端支持，GET方法参数写法可以自己约定。 GET提交到服务端的数据量小（受限于URL长度），而POST数据量大。HTTP协议没有对URL的长度做规定，限制URL长度的大多是浏览器和服务器的配置参数。同样的，HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小。PHP下可以修改 php.conf 的 postmaxsize 来设置POST的大小 GET参数的数据类型只能是ASCII码，而POST无限制（允许二进制数据）。 GET只能进行URL编码，而POST支持多种编码方式。GET: application/x-www-form-urlencodedPOST: application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 GET不应用于传递敏感信息，因为参数直接暴露在URL上。然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是HTTPS。 GET后退按钮/刷新无害，POST数据会被重新提交浏览器应该告知用户数据会被重新提交。 GET请求会保存在浏览器的浏览记录中。 GET请求的URL能够保存为浏览器书签。 GET能被缓存，POST不能缓存。GET时默认可以复用前面的请求数据作为缓存结果返回，此时以完整的URL作为缓存数据的KEY。所以有时候为了强制每次请求都是新数据，我们可以在URL后面加上一个随机参数Math.random或时间戳new Date().getTime()或版本号。 深入理解RFC7231里定义了HTTP方法的几个性质： Safe - 安全性 安全性的定义：对服务端发起的请求没有引起服务端的任何状态变化，则认为符合安全性。 注意这里指的不是上面提到的网络安全方面的安全性。引入安全性主要是方便爬虫和缓存，以免调用某些不安全的方法引起意外的后果。此RFC定义 GET HEAD OPTIONS TRACE 这几个方法是安全的。但这个定义只是规范，并不保证方法的实现也是安全的。 Idempotent - 幂等性 幂等性的定义：一个请求执行一次和执行多次获得的结果是一致的，则认为符合幂等性。 引入幂等性主要是为了处理一个请求重复提交的情况，比如请求响应前失去连接，如果请求方法是幂等的，就可以重新发送请求；如果请求方法不幂等，重复请求可能会带来意想不到的后果。此RFC定义 PUT DELETE 和安全方法都是幂等的。同样，这只是规范，并不保证服务端实现是否幂等。 Cacheable - 可缓存性 就是一个方法是否可以被缓存。此RFC定义 GET HEAD 和某些情况下的 POST 都是可缓存的，但大多数浏览器的实现只支持 GET 和 HEAD 。 这三个性质一直在强调一个事情：协议不等于实现。可以看出，要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比： GET的语义是请求获取指定的资源。GET方法的报文主体没有任何语义。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）。 POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST方法是不安全、不幂等、（大部分实现）不可缓存的。 GET用于获取资源，POST用于处理资源。 POST 方法会产生两个 TCP 数据包？有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"AJAX请求的四个步骤","slug":"ajax","date":"2019-07-01T09:38:30.301Z","updated":"2019-07-01T11:00:19.876Z","comments":true,"path":"2019/07/01/ajax/","link":"","permalink":"http://yoursite.com/2019/07/01/ajax/","excerpt":"AJAX的全称：异步的JavaScript和XML(Asynchronous JavaScript and XML)AJAX不是某种编程语言是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术","text":"AJAX的全称：异步的JavaScript和XML(Asynchronous JavaScript and XML)AJAX不是某种编程语言是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术 创建XMLHttpRequest对象1var xhr = new XMLHttpRequest(); IE5或IE6兼容处理 123456var xhr;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 配置请求信息1open(method,url,async) method：请求方式 —— GET / POSTurl：请求的地址async：true（异步）或 false（同步） 使用GET请求参数加在url后面 1xhr.open(\"GET\", \"server.php?num=100\"); 使用POST请求需要配置请求头信息 12xhr.open(\"POST\", \"server.php\");xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); 发送请求 send 方法发送请求，并接受一个可选参数 1send(string) 使用GET请求可以不传或传入 null 1xhr.send(); 使用POST请求可以将请求体的参数传入 1xhr.send(\"name=evan&amp;num=100\"); 创建响应函数设置 onreadystatechange 的回调函数。在回调函数中，通常我们只需通过 readyState === 4 判断请求是否完成，如果已完成，再根据 status === 200 判断是否是一个成功的响应。 123456789xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"发生错误：\" + xhr.status); &#125; &#125;&#125;; responseText：获得字符串形式的相应数据。 responsXML：获得XML形式的相应数据。 status和statusText：以数字和文本形式返回http状态码。 getAllResponseHeader()：获取所有的响应报头。 getResponseHeader()：查询响应中的某个字段的值。 readyState 属性：响应返回成功的时候得到通知。 0：请求未初始化，open还没有调用。 1：服务器连接已建立，open已经调用了。 2：请求已经接收，也就是接收到头信息了。 3：请求处理中，也就是接收到响应主体了。 4：请求已完成，且响应已就绪，也就是响应完成了。 HTTP 状态码：HTTP状态码由3位数字构成，其中首位数字定义了状态码的类型： 1XX：信息类，表示收到Web浏览器请求，正在进一步的处理中 2XX：成功，表示用户请求被正确接收，理解和处理。例如：200 OK 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found，意味着请求中所引用的文档不存在。 5XX：服务器错误，表示服务器不能完成对请求的处理。例如：500 在 jQuery 中的用法12345678910111213141516171819202122232425$.ajax(&#123; // type: 类型， \"POST\" 或 \"GET\" ，默认为 \"GET\" type: \"POST\", // url：发送请求的地址 url: \"server.php\", // data：是一个对象，连同请求发送到服务器的数据 data: &#123; name: evan, number: 100 &#125;, // 预期服务器返回的数据类型 dataType: \"json\", // 是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串 success: function(data)&#123; if (data.success) &#123; console.log(data.msg); &#125; else &#123; console.log(\"出现错误：\" + data.msg); &#125; &#125;, // 是一个方法，请求失败时调用此函数。传入XMLHttpRequest对象 error: function(jqXHR)&#123; console.log(\"发生错误：\" + jqXHR.status); &#125;, &#125;); 具体的 dataType 解释： 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP包 MIME信息来智能判断，比如 XML MIME类型就被识别为 XML 。在 1.4 中， JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: &quot;xml&quot;：返回 XML 文档，可用 jQuery 处理。 &quot;html&quot;：返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 &quot;script&quot;：返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 &quot;cache&quot; 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script 标签来加载） &quot;json&quot;：返回 JSON 数据。 &quot;jsonp&quot;：JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 &quot;text&quot;：返回纯文本字符串。","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"正则表达式","slug":"regular-expression","date":"2019-06-28T15:30:31.122Z","updated":"2019-08-21T15:38:48.944Z","comments":true,"path":"2019/06/28/regular-expression/","link":"","permalink":"http://yoursite.com/2019/06/28/regular-expression/","excerpt":"正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象，其体系参照 Perl 5 建立。","text":"正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象，其体系参照 Perl 5 建立。 创建正则表达式的方法 使用一个正则表达式字面量 1var re = /xxx/ 调用 RegExp 对象的构造函数 1var re = new RegExp(&apos;xxx&apos;) 两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。 正则表达式的实例属性分为两类 修饰符（只读）RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。用于忽略字符串大小写。RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。用于全局匹配。RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。用于设置匹配为多行模式。 其他属性RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 实例方法1. RegExp.prototype.test()test 方法返回布尔值，表示当前模式是否能匹配参数字符串 1/a/.test(&apos;and&apos;) // true 2. RegExp.prototype.exec()exec方法，用来返回匹配结果如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null 1/a/.exec(&apos;adbca&apos;) 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。 1234String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 字面量字符和元字符元字符 点字符（.)匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。 位置字符 12^ 表示字符串的开始位置$ 表示字符串的结束位置 选择符（|）表示“或关系” 转义符匹配元字符本身可以在它们前面加反斜杠构造函数需要两次转义 特殊字符 12345678910\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。[\\b] 匹配退格键(U+0008)，不要与\\b混淆。\\n 匹配换行键。\\r 匹配回车键。\\t 匹配制表符 tab（U+0009）。\\v 匹配垂直制表符（U+000B）。\\f 匹配换页符（U+000C）。\\0 匹配null字符（U+0000）。\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。 字符类字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示x、y、z之中任选一个匹配。 脱字符（^）：需在字符类第一位表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。 连字符（-）1234[0-9.,][0-9a-fA-F][a-zA-Z0-9-][1-31] // 不代表1到31，只代表1到3 预定义模式：某些常见模式的简写方式12345678\\d 匹配0-9之间的任一数字，相当于[0-9]。\\D 匹配所有0-9以外的字符，相当于[^0-9]。\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\\b 匹配词的边界。\\B 匹配非词边界，即在词的内部 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 量词符：设定某个模式出现的次数123? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。 贪婪模式12var s = &apos;aaa&apos;;s.match(/a+/) // [&quot;aaa&quot;] 贪婪模式改为非贪婪模式 12*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 字符串去空格(replace)123var str = &apos; #id div.class &apos;;str.trim() // &quot;#id div.class&quot;str.replace(/^\\s+|\\s+$/g, &apos;&apos;) // &quot;#id div.class&quot; 12345$&amp;：匹配的子字符串。$`：匹配结果前面的文本。$’：匹配结果后面的文本。$n：匹配成功的第n组内容，n是从1开始的自然数。$$：指代美元符号$。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"JavaScript 数组去重","slug":"array-deduplication","date":"2019-06-24T02:24:16.602Z","updated":"2019-08-11T19:02:06.967Z","comments":true,"path":"2019/06/24/array-deduplication/","link":"","permalink":"http://yoursite.com/2019/06/24/array-deduplication/","excerpt":"记录几种数组去重的方法循环嵌套、indexOf、indexOf 索引判断、sort 排序去邻、Object 键值对、ES6 Set","text":"记录几种数组去重的方法循环嵌套、indexOf、indexOf 索引判断、sort 排序去邻、Object 键值对、ES6 Set 循环嵌套外层循环遍历原始数组，内层循环遍历新数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中。 123456789101112131415function unique(arr) &#123; var res = []; for (i = 0; i &lt; arr.length; i++) &#123; for (j = 0; j &lt; res.length; j++) &#123; if (arr[i] === res[j]) &#123; break; &#125; &#125; // 如果元素唯一，循环完成后 j 等于 res.length if (j === res.length) &#123; res.push(arr[i]); &#125; &#125; return res;&#125; indexOf遍历原始数组的每一个元素，调用 indexOf 方法检测新数组中是否有该元素，如果元素不在新数组中，则将其添加。 123456789function unique(arr) &#123; var res = []; for (i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]); &#125; &#125; return res;&#125; indexOf 索引判断调用 indexOf 方法检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素。 123456789function unique(arr) &#123; var res = []; for (i = 0; i &lt; arr.length; i++) &#123; if (arr.indexOf(arr[i]) === i) &#123; res.push(arr[i]); &#125; &#125; return res;&#125; sort 排序去邻调用 sort 方法对原始数组进行排序，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束。 12345678910111213function unique(arr) &#123; arr = arr.sort(); var res = [], temp; for (i = 0; i &lt; arr.length; i++) &#123; // 第一个元素或与上一个相邻元素不相等 if (!i || arr[i] !== temp) &#123; res.push(arr[i]); &#125; temp = arr[i]; &#125; return res;&#125; Object 键值对创建一个空的 Object 对象，遍历原始数组，把数组的元素存成 Object 的 key ，并给对应的 value 赋值 true ，在判断另一个元素时，如果对应的 value 值为 true，则该元素重复。 1234567891011function unique(arr) &#123; var res = [], obj = &#123;&#125;; for (i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; res.push(arr[i]); obj[arr[i]] = true; &#125; &#125; return res;&#125; ES6 Set123function unique (arr) &#123; return Array.from(new Set(arr));&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-21T10:49:39.694Z","updated":"2019-06-21T10:57:16.667Z","comments":true,"path":"2019/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}