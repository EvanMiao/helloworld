<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 生命周期 | Evan Miao</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Vue 的生命周期的思想贯穿在组件开发的始终，通过熟悉其生命周期调用不同的钩子函数，我们可以准确地控制数据流和其对 DOM 的影响； Vue 生命周期的思想是 Vnode 和 MVVM 的生动体现和继承。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.b33b3459.css" as="style"><link rel="preload" href="/assets/js/app.54eb5da5.js" as="script"><link rel="preload" href="/assets/js/6.921146d0.js" as="script"><link rel="preload" href="/assets/js/3.6e0db218.js" as="script"><link rel="preload" href="/assets/js/24.d69f6f45.js" as="script"><link rel="prefetch" href="/assets/js/10.8df6afd1.js"><link rel="prefetch" href="/assets/js/11.ea21541e.js"><link rel="prefetch" href="/assets/js/12.fece939c.js"><link rel="prefetch" href="/assets/js/13.ec9a6126.js"><link rel="prefetch" href="/assets/js/14.00097767.js"><link rel="prefetch" href="/assets/js/15.b93cb573.js"><link rel="prefetch" href="/assets/js/16.104f977f.js"><link rel="prefetch" href="/assets/js/17.c0d820b2.js"><link rel="prefetch" href="/assets/js/18.6403f4d0.js"><link rel="prefetch" href="/assets/js/19.af6f2bb9.js"><link rel="prefetch" href="/assets/js/20.5974bf52.js"><link rel="prefetch" href="/assets/js/21.9b60c318.js"><link rel="prefetch" href="/assets/js/22.1d1b53a9.js"><link rel="prefetch" href="/assets/js/23.54404127.js"><link rel="prefetch" href="/assets/js/25.cacdd98f.js"><link rel="prefetch" href="/assets/js/26.9e5df746.js"><link rel="prefetch" href="/assets/js/27.8cbb4d9e.js"><link rel="prefetch" href="/assets/js/28.0fb9ea6e.js"><link rel="prefetch" href="/assets/js/29.b3eef4a4.js"><link rel="prefetch" href="/assets/js/30.d95afe7d.js"><link rel="prefetch" href="/assets/js/31.344bbc4c.js"><link rel="prefetch" href="/assets/js/32.2544fc6e.js"><link rel="prefetch" href="/assets/js/4.9b493ed8.js"><link rel="prefetch" href="/assets/js/5.7037f85f.js"><link rel="prefetch" href="/assets/js/7.d7e3ede3.js"><link rel="prefetch" href="/assets/js/8.d193aae7.js"><link rel="prefetch" href="/assets/js/9.16f91c41.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.2e9678df.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b33b3459.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">Evan Miao </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tag</a></li><li class="nav-item"><a href="/about/" class="nav-link">About</a></li><li class="nav-item"><a href="https://github.com/evanmiao" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Evan Miao </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Home</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tag</a></li><li class="mobile-nav-item"><a href="/about/" class="nav-link">About</a></li><li class="mobile-nav-item"><a href="https://github.com/evanmiao" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Vue 生命周期
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2019-09-01T00:00:00.000Z">
      Sun Sep 01 2019
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/Vue" data-v-42ccfcd5><span data-v-42ccfcd5>Vue</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/学习笔记" data-v-42ccfcd5><span data-v-42ccfcd5>学习笔记</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="概念解释"><a href="#概念解释" class="header-anchor">#</a> 概念解释</h2> <blockquote><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p></blockquote> <p>官方的图解：</p> <p><img src="https://i.loli.net/2020/05/13/9WEgmzXZQIKljq7.png" alt="lifecycle.png"></p> <p>简单地说， Vue 实例从创建到销毁的过程，就是生命周期。而这个过程中各种各样的事件，就是生命周期钩子函数。这些函数会在实例生命周期的不同阶段被调用，从而让开发人员的代码控制实例的行为。</p> <p>Vue 的生命周期的思想贯穿在组件开发的始终，通过熟悉其生命周期调用不同的钩子函数，我们可以准确地控制数据流和其对 DOM 的影响； Vue 生命周期的思想是 Vnode 和 MVVM 的生动体现和继承。</p> <h2 id="生命周期与钩子函数"><a href="#生命周期与钩子函数" class="header-anchor">#</a> 生命周期与钩子函数</h2> <table><thead><tr><th>生命周期钩子</th> <th>详细</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td></tr> <tr><td>created</td> <td>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</td></tr> <tr><td>mounted</td> <td>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</td></tr> <tr><td>beforeUpdate</td> <td>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</td></tr> <tr><td>updated</td> <td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</td></tr> <tr><td>activated</td> <td>被 keep-alive 缓存的组件激活时调用。</td></tr> <tr><td>deactivated</td> <td>被 keep-alive 缓存的组件停用时调用。</td></tr> <tr><td>beforeDestroy</td> <td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr> <tr><td>destroyed</td> <td>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</td></tr> <tr><td>errorCaptured</td> <td>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</td></tr></tbody></table> <p>注：除了 beforeCreate 和 created 钩子之外，其他钩子函数均在服务器端渲染期间不被调用。</p> <h3 id="新建-vue-实例"><a href="#新建-vue-实例" class="header-anchor">#</a> 新建 Vue 实例</h3> <p><code>new Vue()</code></p> <h3 id="初始化事件和生命周期"><a href="#初始化事件和生命周期" class="header-anchor">#</a> 初始化事件和生命周期</h3> <p>现在这个实例对象上只有默认的一些生命周期函数和默认的事件。</p> <h3 id="beforecreate-钩子"><a href="#beforecreate-钩子" class="header-anchor">#</a> beforeCreate 钩子</h3> <p>在实例初始化之后，数据观测和事件配置之前调用。</p> <ul><li>不能访问 <code>data</code> <code>computed</code> <code>watch</code> <code>methods</code> 上的方法和数据。</li> <li><code>$route</code> 存在，因此此阶段就可以根据路由信息进行重定向等操作。</li></ul> <p>应用场景：</p> <ul><li>可以在这加个 loading 事件。</li> <li>用于初始化非响应式变量。</li></ul> <h3 id="初始化数据"><a href="#初始化数据" class="header-anchor">#</a> 初始化数据</h3> <p>通过依赖注入导入依赖项，完成数据（ <code>data</code> <code>props</code> 等）的初始化。</p> <h3 id="created-钩子"><a href="#created-钩子" class="header-anchor">#</a> created 钩子</h3> <p>实例已经创建完成之后调用。</p> <ul><li>可访问 <code>data</code> <code>computed</code> <code>watch</code> <code>methods</code> 上的方法和数据。</li> <li><code>DOM</code> 未生成， <code>$el</code> 属性不可访问， <code>$ref</code> 属性内容为空数组。</li> <li>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <code>this.$nextTick</code> 回调函数。</li></ul> <p>应用场景：</p> <ul><li>可以在这结束 loading 。</li> <li>对实例进行预处理，操作 <code>data</code> 数据或操作方法。</li> <li>推荐这个时候发送请求数据，尤其是返回的数据与绑定事件有关时。</li> <li>这个周期中是没有什么方法来对实例化过程进行拦截的。因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个页面发请求。建议在组件导航守卫 <code>beforeRouteEnter</code> 中来完成。</li></ul> <h3 id="模版编译"><a href="#模版编译" class="header-anchor">#</a> 模版编译</h3> <ul><li><p>检查是否有 <code>el</code> 属性</p> <ul><li>检查 <code>vue</code> 配置，即新建实例 <code>new Vue({})</code> 时传入的参数对象是否存在 <code>el</code> 属性，如果有的话就继续向下编译，如果没有则停止编译，直到在该 <code>vue</code> 实例上调用 <code>vm.$mount(el)</code> ，代码才会继续执行。</li></ul></li> <li><p>检查是否有 <code>template</code> 属性</p> <ul><li>检查配置中的 <code>template</code> 属性，如果有则将其作为模板编译成 <code>render</code> 函数，如果没有则将 <code>el</code> 的 <code>outerHTML</code> 作为模板编译。</li> <li>如果有配置中有 <code>render</code> 函数，那么 <code>render</code> 就会替换 <code>template</code> 。</li> <li>优先级： render  &gt;  template &gt; el</li></ul></li></ul> <p>渲染函数 render</p> <blockquote><p>因为 vue 是虚拟 DOM ，所以在拿到 template 模板时也要转译成 VNode （虚拟节点）的函数，而用 render 函数构建 DOM ， vue 就免去了转译的过程。</p> <p>当使用 render 函数描述虚拟 DOM 时， vue 提供一个函数，这个函数是就构建虚拟 DOM 所需要的工具。官网上给他起了个名字叫 createElement 。还有约定它的简写叫 h 。</p></blockquote> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>this is outerHTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    template<span class="token operator">:</span> <span class="token string">'&lt;h1&gt;this is template&lt;/h1&gt;'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'this is createElement'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="beforemount-钩子"><a href="#beforemount-钩子" class="header-anchor">#</a> beforeMount 钩子</h3> <p>在挂载开始之前调用。</p> <ul><li>此时 <code>$el</code> 属性不可访问。</li> <li>将 <code>HTML</code> 解析生成 <code>AST</code> 节点，再根据 <code>AST</code> 节点动态生成渲染函数，相关的 <code>render</code> 函数首次被调用。</li></ul> <h3 id="挂载"><a href="#挂载" class="header-anchor">#</a> 挂载</h3> <p>实例创建 <code>$el</code> 属性并替换所挂载的 DOM 元素( <code>el</code> )。</p> <h3 id="mounted-钩子"><a href="#mounted-钩子" class="header-anchor">#</a> mounted 钩子</h3> <p>实例挂载到页面之后调用。</p> <ul><li>如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li></ul> <p>应用场景：</p> <ul><li>此时可以获取 <code>el</code> 中 <code>DOM</code> 节点，进行 <code>DOM</code> 操作，<code>$ref</code> 属性可以访问。</li> <li>如果返回的数据操作依赖 <code>DOM</code> 完成，推荐这个时候发送数据请求。</li></ul> <h3 id="beforeupdate-钩子"><a href="#beforeupdate-钩子" class="header-anchor">#</a> beforeUpdate 钩子</h3> <p>数据更新时调用，发生在虚拟 <code>DOM</code> 重新渲染和打补丁之前。</p> <ul><li>在这个钩子中进一步地更改状态，不会触发附加的重渲染过程。</li></ul> <p>应用场景：</p> <ul><li>这里适合在更新之前访问现有的 <code>DOM</code>，比如手动移除已添加的事件监听器。</li></ul> <h3 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h3> <p>先根据 <code>data</code> 中的最新数据，在内存中，重新渲染出一份最新的虚拟 <code>DOM</code> 树，当最新的虚拟 <code>DOM</code> 树被更新之后，会把最新的内存 <code>DOM</code> 树重新渲染到真实的页面中去，这个时候就完成数据从 <code>data</code> （模型层）到页面（视图层）的更新。</p> <h3 id="updated-钩子"><a href="#updated-钩子" class="header-anchor">#</a> updated 钩子</h3> <p>数据更新导致的虚拟 <code>DOM</code> 重新渲染和打补丁之后调用。</p> <ul><li>此时组件 <code>DOM</code> 已经更新，可以执行依赖于 <code>DOM</code> 的操作。</li> <li>并不建议在这进行对异步数据得到的 <code>DOM</code> 进行操作，因为有可能你当前的数据不止更改一次，而 <code>updated</code> 只要相关的数据更改一次就会执行一次。</li> <li>大多数情况下，应该避免在此期间更改状态，可能会陷入死循环。如果要相应状态改变，最好使用计算属性或 <code>watcher</code> 取代。</li> <li>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <code>vm.$nextTick</code> 回调函数。</li></ul> <p>应用场景：</p> <ul><li>如果 <code>DOM</code> 操作依赖的数据是在异步操作中获取，并且只有一次数据的更改 （数据更新完毕）时可以对数据更新做一些统一处理。</li></ul> <p>updated 、 watch 和 nextTick 区别</p> <ol><li><p><code>updated</code> 对所有数据的变化进行统一处理</p></li> <li><p><code>watch</code> 对具体某个数据变化做统一处理</p></li> <li><p><code>nextTick</code> 是对某个数据的某一次变化进行处理</p></li></ol> <h3 id="activated-钩子"><a href="#activated-钩子" class="header-anchor">#</a> activated 钩子</h3> <p>被 keep-alive 缓存的组件激活时调用。</p> <ul><li>在使用 <code>vue-router</code> 时有时需要使用 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 来缓存组件状态，这个时候 <code>created</code> 钩子就不会被重复调用了。如果我们的子组件需要在每次加载的时候进行某些操作，可以使用 <code>activated</code> 钩子触发。</li></ul> <h3 id="deactivated-钩子"><a href="#deactivated-钩子" class="header-anchor">#</a> deactivated 钩子</h3> <p>被 keep-alive 缓存的组件停用时调用。</p> <h3 id="beforedestroy-钩子"><a href="#beforedestroy-钩子" class="header-anchor">#</a> beforeDestroy 钩子</h3> <p>实例销毁之前调用。</p> <ul><li>在这一步，实例仍然完全可用（<code>this</code> 仍能获取到）。</li></ul> <p>注： <code>beforeDestroy</code> 和 <code>destroyed</code> 只能通过手动触发 <code>$destroy</code> 来调用。</p> <p>应用场景：</p> <ul><li>一般在这做一些重置的操作，比如清除掉组件中的 定时器 和 监听的 <code>DOM</code> 事件。</li> <li>提示：你确认删除 XX 吗？</li></ul> <h3 id="销毁"><a href="#销毁" class="header-anchor">#</a> 销毁</h3> <p>对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p> <h3 id="destroyed-钩子"><a href="#destroyed-钩子" class="header-anchor">#</a> destroyed 钩子</h3> <p>实例销毁后调用。</p> <ul><li>vue2.0 之后主动调用 <code>$destroy</code> 不会移除 <code>DOM</code> 节点，作者不推荐直接 <code>destroy</code> 这种做法，如果实在需要这样用可以在这个生命周期钩子中手动移除 <code>DOM</code> 节点。</li></ul> <p>应用场景：</p> <ul><li>提示：已删除 XX</li></ul> <h2 id="组件生命周期"><a href="#组件生命周期" class="header-anchor">#</a> 组件生命周期</h2> <h3 id="单个组件"><a href="#单个组件" class="header-anchor">#</a> 单个组件</h3> <ol><li>初始化组件时，仅执行了 beforeCreate/Created/beforeMount/mounted 四个钩子函数。</li> <li>当改变 data 中定义的变量（响应式变量）时，会执行 beforeUpdate/updated 钩子函数。</li> <li>当切换组件（当前组件未缓存）时，会执行 beforeDestory/destroyed 钩子函数。</li> <li>初始化和销毁时的生命钩子函数均只会执行一次， beforeUpdate/updated 可多次执行。</li></ol> <h3 id="父子组件"><a href="#父子组件" class="header-anchor">#</a> 父子组件</h3> <ol><li>仅当子组件完成挂载后，父组件才会挂载。</li> <li>当子组件完成挂载后，父组件会主动执行一次 beforeUpdate/updated 钩子函数（仅首次）。</li> <li>父子组件在 data 变化中是分别监控的，但是在更新 props 中的数据是关联的（可实践）。</li> <li>销毁父组件时，先将子组件销毁后才会销毁父组件。</li></ol> <h3 id="兄弟组件"><a href="#兄弟组件" class="header-anchor">#</a> 兄弟组件</h3> <ol><li>兄弟组件的初始化（ mounted 之前）分开进行，挂载是从上到下依次进行。</li> <li>当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的。</li></ol> <h2 id="vue-3"><a href="#vue-3" class="header-anchor">#</a> Vue 3</h2> <h3 id="替换"><a href="#替换" class="header-anchor">#</a> 替换</h3> <ul><li>beforeCreate -&gt; setup()</li> <li>created -&gt; setup()</li></ul> <h3 id="重命名"><a href="#重命名" class="header-anchor">#</a> 重命名</h3> <ul><li>beforeMount -&gt; onBeforeMount</li> <li>mounted -&gt; onMounted</li> <li>beforeUpdate -&gt; onBeforeUpdate</li> <li>updated -&gt; onUpdated</li> <li>beforeDestroy -&gt; onBeforeUnmount</li> <li>destroyed -&gt; onUnmounted</li> <li>errorCaptured -&gt; onErrorCaptured</li></ul> <h3 id="新增"><a href="#新增" class="header-anchor">#</a> 新增</h3> <ul><li>onRenderTracked</li> <li>onRenderTriggered</li></ul> <p>Vue 3 中建议使用 <code>setup()</code> 代替 <code>beforeCreate</code> 、 <code>created</code> 钩子函数, 虽然 Vue3 兼容 Vue2 的大部分语法, 但是在 Vue3 中慎用以下钩子函数, 以下的生命周期钩子函数被改名后, 在 Vue3 中将不会再有 <code>beforeDestroy</code> 和 <code>destroyed</code></p> <ul><li>beforeDestroy -&gt; onBeforeUnmount</li> <li>destroyed -&gt; onUnmounted</li></ul> <h3 id="生命周期函数执行顺序"><a href="#生命周期函数执行顺序" class="header-anchor">#</a> 生命周期函数执行顺序</h3> <p><code>setup</code> =&gt; <code>onBeforeMount</code> =&gt; <code>onRenderTracked</code> =&gt; <code>onMounted</code> =&gt; <code>onRenderTriggered</code> =&gt; <code>onBeforeUpdate</code> =&gt; <code>onRenderTracked</code> =&gt; <code>OnUpdated</code> =&gt; <code>onBeforeUnmount</code> =&gt; <code>onUnmounted</code></p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#概念解释" title="概念解释">概念解释</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#生命周期与钩子函数" title="生命周期与钩子函数">生命周期与钩子函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#新建-vue-实例" title="新建 Vue 实例">新建 Vue 实例</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#初始化事件和生命周期" title="初始化事件和生命周期">初始化事件和生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#beforecreate-钩子" title="beforeCreate 钩子">beforeCreate 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#初始化数据" title="初始化数据">初始化数据</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#created-钩子" title="created 钩子">created 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#模版编译" title="模版编译">模版编译</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#beforemount-钩子" title="beforeMount 钩子">beforeMount 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#挂载" title="挂载">挂载</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#mounted-钩子" title="mounted 钩子">mounted 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#beforeupdate-钩子" title="beforeUpdate 钩子">beforeUpdate 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#更新" title="更新">更新</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#updated-钩子" title="updated 钩子">updated 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#activated-钩子" title="activated 钩子">activated 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#deactivated-钩子" title="deactivated 钩子">deactivated 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#beforedestroy-钩子" title="beforeDestroy 钩子">beforeDestroy 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#销毁" title="销毁">销毁</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#destroyed-钩子" title="destroyed 钩子">destroyed 钩子</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组件生命周期" title="组件生命周期">组件生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#单个组件" title="单个组件">单个组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#父子组件" title="父子组件">父子组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#兄弟组件" title="兄弟组件">兄弟组件</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#vue-3" title="Vue 3">Vue 3</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#替换" title="替换">替换</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#重命名" title="重命名">重命名</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#新增" title="新增">新增</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#生命周期函数执行顺序" title="生命周期函数执行顺序">生命周期函数执行顺序</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/evanmiao" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li><li class="contact-item" data-v-3d9deeb8><a href="mailto:evan.c.miao@gmail.com" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-3d9deeb8><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-3d9deeb8></path><polyline points="22,6 12,13 2,6" data-v-3d9deeb8></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>Powered by VuePress</a></li><li class="copyright-item" data-v-3d9deeb8><a href="/" class="nav-link" data-v-3d9deeb8>Copyright © 2019 Evan Miao</a></li></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.54eb5da5.js" defer></script><script src="/assets/js/6.921146d0.js" defer></script><script src="/assets/js/3.6e0db218.js" defer></script><script src="/assets/js/24.d69f6f45.js" defer></script>
  </body>
</html>
